<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>ChatGPT Response Similarity Explorer</title>
	<!-- D3 + PapaParse from CDN -->
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
	<!-- Inter font -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
	<style>
	:root{font-family:Consolas,'Courier New',Monaco,monospace}
	body{
		max-width:1800px;
		margin:0 auto;
		padding:24px;
		font-family:'Inter',sans-serif;
		background-color:#fafafa;
		background-image: 
			repeating-linear-gradient(0deg, transparent, transparent 40px, rgba(0,0,0,0.03) 40px, rgba(0,0,0,0.03) 41px),
			repeating-linear-gradient(90deg, transparent, transparent 40px, rgba(0,0,0,0.03) 40px, rgba(0,0,0,0.03) 41px);
	}
	.filter-row{
		display:flex;
		gap:20px;
		align-items:center;
		margin-bottom:24px;
		position:sticky;
		top:0;
		background:#fff;
		padding:16px 0;
		z-index:50;
		border-bottom:1px solid #ddd;
		flex-wrap:wrap;
	}
	.filter-group{
		flex:0 0 auto;
	}
	#promptFilter{
		width:auto;
	}
	#dayFilter{
		min-width:120px;
	}
	#citationTypeFilter{
		min-width:150px;
	}
	.filter-group label{
		display:block;
		font-size:12px;
		font-weight:700;
		color:#333;
		margin-bottom:6px;
	}
	button{cursor:pointer;padding:8px 12px;background:#667eea;color:white;border:none;border-radius:4px;margin:4px 0;font-family:'Inter',sans-serif;}
	button:hover{background:#5568d3}
	select{padding:8px;border:1px solid #ddd;border-radius:4px;font-family:'Inter',sans-serif;}
	h2,h3,p,label{font-family:'Inter',sans-serif;}
	svg text{font-family:Consolas,'Courier New',Monaco,monospace !important;}
		.cell{stroke:#fff}
	.hidden{display:none}
	.color-legend{
		padding:10px 14px;
		background:#fff;
		border-radius:8px;
		box-shadow:0 2px 8px rgba(0,0,0,0.1);
		font-family:'Inter',sans-serif;
		flex:0 1 auto;
		min-width:130px;
	}
	.color-legend-title{
		font-size:10px;
		font-weight:700;
		margin-bottom:6px;
		color:#333;
		text-transform:uppercase;
		letter-spacing:0.5px;
	}
	.color-scale{
		height:18px;
		background:linear-gradient(to right, #ffffff, #ff6666);
		border-radius:4px;
		border:1px solid #ddd;
	}
	.color-labels{
		display:flex;
		justify-content:space-between;
		font-size:11px;
		color:#666;
		margin-top:4px;
	}
	.hero-stat{
		text-align:center;
		padding:12px 16px;
		background:#f5f5f5;
		border-radius:8px;
		flex:0 1 auto;
		min-width:0;
	}
	.hero-stat .label{
		font-size:10px;
		font-weight:700;
		text-transform:uppercase;
		letter-spacing:0.5px;
		color:#999;
		margin-bottom:6px;
		word-wrap:break-word;
	}
	.hero-stat .value{
		font-size:32px;
		font-weight:bold;
		color:#ff6666;
		line-height:1;
	}
	.filter-right{
		display:flex;
		align-items:center;
		gap:12px;
		margin-left:auto;
		flex-shrink:1;
		min-width:0;
	}
	.heatmap-container{
		border:1px solid #eee;
		padding:16px;
		overflow-x:auto;
		overflow-y:visible;
	}
	.heatmap-inner{
		min-width:600px;
		width:fit-content;
		margin:0 auto;
	}
	@media (max-width: 1200px) {
		.filter-right{
			flex-wrap:wrap;
			margin-left:0;
		}
	}
	@media (max-width: 768px) {
		.hero-stat{
			max-width:145px;
			padding:10px 16px;
		}
		.hero-stat .label{
			font-size:9px;
		}
		.hero-stat .value{
			font-size:24px;
		}
		.color-legend{
			min-width:120px;
		}
	}
	</style>
</head>
<body>
	<h2 style="text-align:center;margin-bottom:8px;font-family:Consolas,'Courier New',Monaco,monospace">ChatGPT Response Similarity Explorer</h2>
	<p style="text-align:center;color:#666;font-size:15px;margin:0 0 24px 0">Same prompts, different prompters. Measuring how similar ChatGPT citations are for different users</p>

	<div class="filter-row">
		<div style="flex:1;display:flex;gap:20px;align-items:center;flex-wrap:wrap">
			<div class="filter-group">
				<label>Prompt Filter</label>
				<select id="promptFilter"><option value="__ALL__">All prompts</option></select>
			</div>
			
			<div class="filter-group">
				<label>Day Filter</label>
			<select id="dayFilter"><option value="__ALL__">All days</option></select>
			</div>
			
			<div class="filter-group">
				<label>Citation Type</label>
				<select id="citationTypeFilter">
					<option value="__ALL__">All types</option>
					<option value="Citation" selected>Citation URLs</option>
					<option value="Supporting">Supporting URLs</option>
			</select>
			</div>
		</div>

		<div class="filter-right">
			<div id="heroStat" class="hero-stat">
				<div class="label">Overall ChatGPT Response Similarity</div>
				<div class="value">—</div>
			</div>
			
			<div class="color-legend">
				<div class="color-legend-title">Similarity Scale</div>
				<div class="color-scale"></div>
				<div class="color-labels">
					<span>0%</span>
					<span>100%</span>
				</div>
			</div>
		</div>
	</div>

	<button id="exportMatrix" class="hidden">Export similarity CSV</button>

	<div style="display:flex;gap:32px;margin-top:40px;flex-wrap:wrap">
		<div style="flex:1 1 600px;max-width:100%">
			<h3 style="margin-bottom:16px;font-size:18px">Person-to-Person Similarity</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">Comparing citation overlap between individual participants</p>
			<div class="heatmap-container">
				<div id="chart" class="heatmap-inner"></div>
			</div>
		</div>

		<div style="flex:1 1 600px;max-width:100%">
			<h3 style="margin-bottom:16px;font-size:18px">Day & Prompt Similarity</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">Average similarity between all participants for each day/prompt combination</p>
			<div class="heatmap-container">
				<div id="dayPromptChart" class="heatmap-inner"></div>
			</div>
		</div>
	</div>
	
	<div style="display:flex;gap:32px;margin-top:60px;flex-wrap:wrap">
		<div style="flex:1 1 calc(50% - 16px);min-width:500px;overflow:hidden">
			<h3 style="margin-bottom:16px;font-size:18px">Ever-Present URLs</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">URLs that appear for ALL people within the selected filters</p>
			<div id="consistentUrls" style="border:1px solid #eee;padding:16px;background:#f9f9f9;overflow-x:auto"></div>
		</div>
		
		<div style="flex:1 1 calc(50% - 16px);min-width:500px;overflow:hidden">
			<h3 style="margin-bottom:16px;font-size:18px">Unique URLs</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">URLs that appear for only ONE person within the selected filters</p>
			<div id="uniqueUrls" style="border:1px solid #eee;padding:16px;background:#f9f9f9;overflow-x:auto"></div>
		</div>
	</div>
	
	<div style="display:flex;gap:32px;margin-top:60px;flex-wrap:wrap">
		<div style="flex:1 1 calc(50% - 16px);min-width:500px;overflow:hidden">
			<h3 style="margin-bottom:16px;font-size:18px">Ever-Present Domains</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">Domains that appear for ALL people within the selected filters</p>
			<div id="everPresentDomains" style="border:1px solid #eee;padding:16px;background:#f9f9f9;overflow-x:auto"></div>
		</div>
		
		<div style="flex:1 1 calc(50% - 16px);min-width:500px;overflow:hidden">
			<h3 style="margin-bottom:16px;font-size:18px">Unique Domains</h3>
			<p style="color:#666;font-size:13px;margin-bottom:16px">Domains that appear for only ONE person within the selected filters</p>
			<div id="uniqueDomains" style="border:1px solid #eee;padding:16px;background:#f9f9f9;overflow-x:auto"></div>
		</div>
	</div>

	<script>
		// Use tabs for indentation throughout
		const promptFilter = document.getElementById('promptFilter')
		const dayFilter = document.getElementById('dayFilter')
	const citationTypeFilter = document.getElementById('citationTypeFilter')
		const exportBtn = document.getElementById('exportMatrix')
	const heroStat = document.getElementById('heroStat')

	let rawRows = []
	let users = []
	let prompts = []
	let days = []
	let currentHeroValue = 0 // Track current hero stat value for animation
	
	// Anonymous name mapping
	const nameMapping = {
		'Alex Wright': 'Person 1',
		'Alice Klein': 'Person 2',
		'David Reid': 'Person 3',
		'James Smith': 'Person 4',
		'Jim Podmore': 'Person 5',
		'Jon Hogg': 'Person 6',
		'Jonny Lyon': 'Person 7',
		'Katherine Cook': 'Person 8',
		'Paige McCormick': 'Person 9',
		'Rachael Murdoch': 'Person 10'
	}
	
	function anonymizeName(name) {
		return nameMapping[name] || name
	}

	// Animate hero stat number counting up/down
	function animateHeroStat(targetValue) {
		const duration = 600 // milliseconds
		const startValue = currentHeroValue
		const startTime = performance.now()
		const valueElement = heroStat.querySelector('.value')
		
		function updateValue(currentTime) {
			const elapsed = currentTime - startTime
			const progress = Math.min(elapsed / duration, 1)
			
			// Easing function (ease-out)
			const easeProgress = 1 - Math.pow(1 - progress, 3)
			
			const currentVal = startValue + (targetValue - startValue) * easeProgress
			valueElement.textContent = Math.round(currentVal) + '%'
			
			if (progress < 1) {
				requestAnimationFrame(updateValue)
			} else {
				currentHeroValue = targetValue
			}
		}
		
		requestAnimationFrame(updateValue)
	}

		function parseCSVData(res) {
					console.log('CSV parsed. Rows:', res.data.length)
					if(res.data.length > 0) {
						console.log('First row columns:', Object.keys(res.data[0]))
						console.log('First row sample:', res.data[0])
					}
					
					// Check if headers are numeric (means CSV had no header row detected)
					const firstRow = res.data[0]
					const keys = Object.keys(firstRow)
					const hasNumericKeys = keys.every(k => !isNaN(k))
					
					let dataToProcess = res.data
					if(hasNumericKeys && firstRow['0'] === 'name') {
						// First row is actually headers, skip it
						console.log('Detected headers as data, skipping first row')
						dataToProcess = res.data.slice(1)
					}
					
					const normalised = dataToProcess.map(row => {
						const r = {};
						// Handle both numeric keys (0,1,2) and named keys
						if(hasNumericKeys) {
							// Map numeric indices to names
							r['name'] = row['0'] || ''
							r['day'] = row['1'] || ''
							r['prompt'] = row['2'] || ''
							r['date'] = row['3'] || ''
							r['citation type'] = row['4'] || ''
							r['url clean'] = row['5'] || ''
						} else {
							// Normal named keys
							for (const key in row) r[key.toLowerCase()] = row[key];
						}
						return {
							Name: (r['name']||'').trim(),
							Day: (r['day']||'').trim(),
							Prompt: (r['prompt']||'').trim(),
							Date: (r['date']||'').trim(),
							CitationType: (r['citation type']||'').trim(),
							URL: (r['url clean']||'').trim()
						};
					});
					rawRows = normalised;
					console.log('Normalised rows:', rawRows.length)
					console.log('Sample normalised:', rawRows[0])
					storeData();
					initialise();
		}

		// Auto-load data.csv on page load
		function loadDefaultData() {
			console.log('Loading default data.csv...')
			Papa.parse('data.csv', {
				header: true,
				skipEmptyLines: true,
				download: true,
				complete: parseCSVData,
				error: function(err){
				console.error('Error loading data.csv:', err)
				heroStat.querySelector('.value').textContent = 'Error'
			}
			})
		}

		function storeData(){
			try{localStorage.setItem('jaccard_rows', JSON.stringify(rawRows))}catch(e){console.warn('localStorage error',e)}
		}

		function initialise(){
			users = Array.from(new Set(rawRows.map(r=>r.Name).filter(Boolean))).sort()
			prompts = Array.from(new Set(rawRows.map(r=>r.Prompt).filter(Boolean))).sort()
			days = Array.from(new Set(rawRows.map(r=>r.Day).filter(Boolean))).sort()

			console.log('Initialised. Users:', users.length, users)
			console.log('Prompts:', prompts.length, prompts)
			console.log('Days:', days.length, days)

			// populate filters
		promptFilter.innerHTML = '<option value="__ALL__">All prompts</option>' + prompts.map(p=>`<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join('')
			dayFilter.innerHTML = '<option value="__ALL__">All days</option>' + days.map(d=>`<option value="${escapeHtml(d)}">${escapeHtml(d)}</option>`).join('')

			render()
		}

		function escapeHtml(s){return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')}

		promptFilter.addEventListener('change', render)
		dayFilter.addEventListener('change', render)
	citationTypeFilter.addEventListener('change', render)

		exportBtn.addEventListener('click', ()=>{
			const matrix = computeSimilarityGrid()
			if(!matrix) return
			const csv = matrixToCSV(matrix)
			const blob = new Blob([csv],{type:'text/csv'})
			const url = URL.createObjectURL(blob)
			const a = document.createElement('a')
			a.href = url
			a.download = 'jaccard_similarity_matrix.csv'
			a.click()
			URL.revokeObjectURL(url)
		})

	function matrixToCSV(mat){
		const header = ['User', ...mat.users.map(u=>anonymizeName(u))].join(',')
		const rows = mat.users.map((u,i)=>[anonymizeName(u), ...mat.grid[i].map(v=>v.toFixed(4))].join(','))
		return [header,...rows].join('\n')
	}

		function computeSimilarityGrid(){
			if(!rawRows.length){alert('No data');return null}
			const promptVal = promptFilter.value
			const dayVal = dayFilter.value
		const citationTypeVal = citationTypeFilter.value
			// Build map: prompt -> user -> set(urls)
			const promptUserMap = new Map()
			for(const r of rawRows){
				if(dayVal!=='__ALL__' && r.Day!==dayVal) continue
			if(citationTypeVal!=='__ALL__' && r.CitationType!==citationTypeVal) continue
				const p = r.Prompt||'__MISSING__'
				if(promptVal!=='__ALL__' && p!==promptVal) continue
				if(!promptUserMap.has(p)) promptUserMap.set(p, new Map())
				const userMap = promptUserMap.get(p)
				if(!userMap.has(r.Name)) userMap.set(r.Name, new Set())
				if(r.URL) userMap.get(r.Name).add(r.URL)
			}

			function jaccard(a,b){
				if(a.size===0 && b.size===0) return 0
				let inter=0
				for(const x of a) if(b.has(x)) inter++
				const uni = new Set([...a,...b]).size
				return uni===0?0:inter/uni
			}

			// Build per-prompt pair scores
		// Only include users who actually participated in the filtered data
		const participatingUsers = new Set()
		for(const uMap of promptUserMap.values()){
			for(const userName of uMap.keys()){
				if(uMap.get(userName).size > 0) participatingUsers.add(userName)
			}
		}
		const activeUserList = Array.from(participatingUsers)
		
		if(activeUserList.length === 0) {
			return {users:[],grid:[]}
		}
		
			const perPromptScores = []
			for(const [p, uMap] of promptUserMap.entries()){
			const grid = Array.from({length:activeUserList.length}, ()=>Array(activeUserList.length).fill(0))
			for(let i=0;i<activeUserList.length;i++){
				for(let j=0;j<activeUserList.length;j++){
					const ai = uMap.get(activeUserList[i])||new Set()
					const bj = uMap.get(activeUserList[j])||new Set()
						grid[i][j] = jaccard(ai,bj)
					}
				}
				perPromptScores.push(grid)
			}

			if(perPromptScores.length===0){
			return {users:[],grid:[]}
			}

	// Aggregate across prompts using mean
		const M = activeUserList.length
			const finalGrid = Array.from({length:M}, ()=>Array(M).fill(0))
			for(let i=0;i<M;i++){
				for(let j=0;j<M;j++){
					const vals = perPromptScores.map(g=>g[i][j])
			const sum = vals.reduce((a,b)=>a+b,0)
			finalGrid[i][j] = sum/vals.length
			}
		}

		return {users:activeUserList,grid:finalGrid}
		}

		function render(){
			console.log('Render called')
			const mat = computeSimilarityGrid()
			console.log('Similarity matrix computed:', mat ? `${mat.users.length} users` : 'null')
			if(!mat) return
			d3.select('#chart').selectAll('*').remove()
		
		const cellSize = 48
		const labelWidth = 100
		const labelHeight = 100
		const svgWidth = labelWidth + mat.users.length * cellSize + 20
		const svgHeight = labelHeight + mat.users.length * cellSize + 20
		
		const svg = d3.select('#chart').append('svg')
			.attr('width', svgWidth)
			.attr('height', svgHeight)

		const color = d3.scaleLinear().domain([0,1]).range(['#ffffff','#ff6666'])

		// rows
	const g = svg.append('g').attr('transform',`translate(${labelWidth},${labelHeight})`)
		// labels
		g.selectAll('.rowLabel').data(mat.users).enter().append('text')
			.attr('x',-6).attr('y',(d,i)=>i*cellSize+cellSize/1.5)
		.attr('text-anchor','end')
		.attr('font-size', 13)
		.attr('font-weight', 'bold')
		.text(d=>anonymizeName(d))
		g.selectAll('.colLabel').data(mat.users).enter().append('text')
			.attr('x',(d,i)=>i*cellSize+cellSize/2).attr('y',-6)
			.attr('text-anchor','start')
		.attr('font-size', 13)
		.attr('font-weight', 'bold')
			.attr('transform',(d,i)=>`rotate(-45 ${i*cellSize+cellSize/2} -6)`)
			.text(d=>anonymizeName(d))

		const rows = g.selectAll('.row').data(mat.grid).enter().append('g').attr('transform',(d,i)=>`translate(0,${i*cellSize})`)
	rows.selectAll('rect').data((d,rowIdx)=>d.map((val,colIdx)=>({val,rowIdx,colIdx})).filter(d=>d.rowIdx >= d.colIdx)).enter().append('rect')
			.attr('x',d=>d.colIdx*cellSize).attr('y',0).attr('width',cellSize-2).attr('height',cellSize-2)
			.attr('class','cell')
			.style('fill',d=>{
				// Don't color the diagonal (same person)
				if(d.rowIdx === d.colIdx) return '#f5f5f5'
				return color(d.val)
			})
		
		// Add text labels with percentage
	rows.selectAll('text').data((d,rowIdx)=>d.map((val,colIdx)=>({val,rowIdx,colIdx})).filter(d=>d.rowIdx >= d.colIdx)).enter().append('text')
			.attr('x',d=>d.colIdx*cellSize+cellSize/2)
			.attr('y',cellSize/2)
			.attr('dy','0.35em')
			.attr('text-anchor','middle')
		.attr('font-size', Math.min(14, cellSize/3))
		.attr('font-weight', 'bold')
			.attr('fill', d=>{
				// Different text color for diagonal
				if(d.rowIdx === d.colIdx) return '#999'
		return '#000'
	})
		.text(d=>{
			// Show dash for diagonal (self-comparison)
			if(d.rowIdx === d.colIdx) return '—'
			return Math.round(d.val*100)+'%'
		})

		// stats - exclude diagonal from average (those are self-comparisons)
		const offDiagonal = []
		for(let i=0; i<mat.grid.length; i++) {
			for(let j=0; j<mat.grid[i].length; j++) {
				if(i !== j) offDiagonal.push(mat.grid[i][j])
			}
		}
		const avg = offDiagonal.length > 0 ? offDiagonal.reduce((a,b)=>a+b,0)/offDiagonal.length : 0
		
	// Update hero stat with animation
	animateHeroStat(avg * 100)
	
	// Render day/prompt heatmap
	renderDayPromptHeatmap()
	
	// Render consistent URLs table
	renderConsistentUrls()
	
	// Render unique URLs table
	renderUniqueUrls()
	
	// Render ever-present domains table
	renderEverPresentDomains()
	
	// Render unique domains table
	renderUniqueDomains()
	}

	function renderDayPromptHeatmap() {
		if(!rawRows.length) return
		
		const citationTypeVal = citationTypeFilter.value
		
		// Build structure: day -> prompt -> users -> urls
		const structure = new Map()
		for(const r of rawRows) {
			if(citationTypeVal!=='__ALL__' && r.CitationType!==citationTypeVal) continue
			
			const day = r.Day || '__MISSING__'
			const prompt = r.Prompt || '__MISSING__'
			const user = r.Name
			
			if(!structure.has(day)) structure.set(day, new Map())
			if(!structure.get(day).has(prompt)) structure.get(day).set(prompt, new Map())
			if(!structure.get(day).get(prompt).has(user)) structure.get(day).get(prompt).set(user, new Set())
			if(r.URL) structure.get(day).get(prompt).get(user).add(r.URL)
		}
		
		// Calculate average similarity for each day/prompt combination
		const dayList = days.slice().sort()
		const promptList = prompts.slice().sort()
		
		function jaccard(a,b){
			if(a.size===0 && b.size===0) return 0
			let inter=0
			for(const x of a) if(b.has(x)) inter++
			const uni = new Set([...a,...b]).size
			return uni===0?0:inter/uni
		}
		
		// Build grid: prompts (rows) x days (cols)
		const grid = []
		for(const prompt of promptList) {
			const row = []
			for(const day of dayList) {
				const userMap = structure.get(day)?.get(prompt)
				if(!userMap || userMap.size < 2) {
					row.push(null) // Not enough data
					continue
				}
				
				// Calculate average similarity between all pairs of users
				const userList = Array.from(userMap.keys())
				let sumSim = 0
				let count = 0
				for(let i=0; i<userList.length; i++) {
					for(let j=i+1; j<userList.length; j++) {
						const sim = jaccard(userMap.get(userList[i]), userMap.get(userList[j]))
						sumSim += sim
						count++
					}
				}
				row.push(count > 0 ? sumSim / count : 0)
			}
			grid.push(row)
		}
		
	// Render with D3
	d3.select('#dayPromptChart').selectAll('*').remove()
	
	const cellSize = 80
	const labelWidth = 320
	const labelHeight = 40
		const width = labelWidth + dayList.length * cellSize + 20
		const height = labelHeight + promptList.length * cellSize + 20
		
		const svg = d3.select('#dayPromptChart').append('svg')
			.attr('width', width)
			.attr('height', height)
		
		const color = d3.scaleLinear().domain([0,1]).range(['#ffffff','#ff6666'])
		
		const g = svg.append('g').attr('transform', `translate(${labelWidth},${labelHeight})`)
		
	// Column labels (days)
	g.selectAll('.colLabel').data(dayList).enter().append('text')
		.attr('x',(d,i)=>i*cellSize+cellSize/2).attr('y',-6)
		.attr('text-anchor','middle')
		.attr('font-size', 14)
		.attr('font-weight', 'bold')
		.text(d=>d)
		
	// Row labels (prompts) - with wrapping
	const wrapWidth = 300
	g.selectAll('.rowLabel').data(promptList).enter().append('text')
		.attr('x',-6).attr('y',(d,i)=>i*cellSize+cellSize/2)
		.attr('text-anchor','end')
		.attr('font-size', 12)
		.attr('font-weight', 'bold')
		.each(function(d) {
			const text = d3.select(this)
			const words = d.split(/\s+/)
			let line = []
			let lineNumber = 0
			const lineHeight = 1.1
			const y = text.attr('y')
			const dy = 0
			let tspan = text.append('tspan').attr('x', -6).attr('y', y).attr('dy', dy + 'em')
			
			words.forEach(word => {
				line.push(word)
				tspan.text(line.join(' '))
				if (tspan.node().getComputedTextLength() > wrapWidth) {
					line.pop()
					tspan.text(line.join(' '))
					line = [word]
					lineNumber++
					tspan = text.append('tspan')
						.attr('x', -6)
						.attr('y', y)
						.attr('dy', lineNumber * lineHeight + 'em')
						.text(word)
				}
			})
		})
		
		// Cells
		const rows = g.selectAll('.row').data(grid).enter().append('g')
			.attr('transform',(d,i)=>`translate(0,${i*cellSize})`)
		
	rows.selectAll('rect').data((d,rowIdx)=>d.map((val,colIdx)=>({val,rowIdx,colIdx})))
		.enter().append('rect')
		.attr('x',d=>d.colIdx*cellSize).attr('y',0)
		.attr('width',cellSize-2).attr('height',cellSize-2)
		.attr('class','cell')
		.style('fill',d=>{
			if(d.val === null) return '#f5f5f5'
			return color(d.val)
		})
		
	// Text labels
	rows.selectAll('text').data((d,rowIdx)=>d.map((val,colIdx)=>({val,rowIdx,colIdx})))
		.enter().append('text')
		.attr('x',d=>d.colIdx*cellSize+cellSize/2)
		.attr('y',cellSize/2)
		.attr('dy','0.35em')
		.attr('text-anchor','middle')
		.attr('font-size', 14)
		.attr('font-weight', 'bold')
	.attr('fill', d=>{
		if(d.val === null) return '#999'
		return '#000'
	})
		.text(d=>{
			if(d.val === null) return '—'
			return Math.round(d.val*100)+'%'
		})
	}

	function renderConsistentUrls() {
		if(!rawRows.length) return
		
		const container = document.getElementById('consistentUrls')
		container.innerHTML = ''
		
		const promptVal = promptFilter.value
		const dayVal = dayFilter.value
		const citationTypeVal = citationTypeFilter.value
		
		// Filter rows based on current filters
		const filteredRows = rawRows.filter(r => {
			if(promptVal !== '__ALL__' && r.Prompt !== promptVal) return false
			if(dayVal !== '__ALL__' && r.Day !== dayVal) return false
			if(citationTypeVal !== '__ALL__' && r.CitationType !== citationTypeVal) return false
			return r.URL && r.URL.trim() !== ''
		})
		
		if(filteredRows.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No data for the selected filters</p>'
			return
		}
		
		// Group by URL
		const urlStats = new Map()
		for(const row of filteredRows) {
			if(!urlStats.has(row.URL)) {
				urlStats.set(row.URL, {
					url: row.URL,
					people: new Set(),
					days: new Set(),
					prompts: new Set(),
					count: 0
				})
			}
			const stats = urlStats.get(row.URL)
			stats.people.add(row.Name)
			stats.days.add(row.Day)
			stats.prompts.add(row.Prompt)
			stats.count++
		}
		
		// Convert to array and calculate consistency metrics
		const urlArray = Array.from(urlStats.values()).map(stats => ({
			url: stats.url,
			peopleCount: stats.people.size,
			daysCount: stats.days.size,
			promptsCount: stats.prompts.size,
			totalCount: stats.count
		}))
		
		// Sort by number of people (most consistent first)
		urlArray.sort((a, b) => {
			if(b.peopleCount !== a.peopleCount) return b.peopleCount - a.peopleCount
			if(b.daysCount !== a.daysCount) return b.daysCount - a.daysCount
			return b.totalCount - a.totalCount
		})
		
		// Show only URLs that appear for ALL people (ever-present)
		const totalPeople = users.length
		const consistentUrls = urlArray.filter(u => u.peopleCount === totalPeople)
		
		if(consistentUrls.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No URLs appeared for all people</p>'
			return
		}
		
	// Create table
	const table = document.createElement('table')
	table.style.width = 'auto'
	table.style.minWidth = '100%'
	table.style.borderCollapse = 'collapse'
	table.style.fontFamily = "'Inter',sans-serif"
	table.style.fontSize = '13px'
	table.style.background = '#fff'
		
		// Header
		const thead = table.createTHead()
		const headerRow = thead.insertRow()
		headerRow.style.background = '#f5f5f5'
		headerRow.style.fontWeight = 'bold'
		
		const headers = ['URL', 'People', 'Days', 'Prompts']
		headers.forEach(text => {
			const th = document.createElement('th')
			th.textContent = text
			th.style.padding = '12px'
			th.style.textAlign = 'left'
			th.style.borderBottom = '2px solid #ddd'
			headerRow.appendChild(th)
		})
		
		// Body
		const tbody = table.createTBody()
		consistentUrls.slice(0, 50).forEach((urlData, idx) => {
			const row = tbody.insertRow()
			row.style.borderBottom = '1px solid #eee'
			if(idx % 2 === 0) row.style.background = '#fafafa'
			
		// URL cell
		const urlCell = row.insertCell()
		urlCell.style.padding = '10px 12px'
		urlCell.style.maxWidth = '400px'
		const link = document.createElement('a')
		link.href = urlData.url
		link.target = '_blank'
		link.textContent = urlData.url
		link.style.color = '#0066cc'
		link.style.textDecoration = 'none'
		link.style.wordBreak = 'break-all'
		link.addEventListener('mouseover', () => link.style.textDecoration = 'underline')
		link.addEventListener('mouseout', () => link.style.textDecoration = 'none')
		urlCell.appendChild(link)
			
			// Stats cells
			const peopleCell = row.insertCell()
			peopleCell.textContent = urlData.peopleCount
			peopleCell.style.padding = '10px 12px'
			peopleCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			peopleCell.style.textAlign = 'center'
			
			const daysCell = row.insertCell()
			daysCell.textContent = urlData.daysCount
			daysCell.style.padding = '10px 12px'
			daysCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			daysCell.style.textAlign = 'center'
			
		const promptsCell = row.insertCell()
		promptsCell.textContent = urlData.promptsCount
		promptsCell.style.padding = '10px 12px'
		promptsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
		promptsCell.style.textAlign = 'center'
	})
	
	container.appendChild(table)
	
	if(consistentUrls.length > 50) {
			const note = document.createElement('p')
			note.style.marginTop = '12px'
			note.style.fontSize = '12px'
			note.style.color = '#666'
			note.style.fontStyle = 'italic'
			note.textContent = `Showing top 50 of ${consistentUrls.length} consistent URLs`
			container.appendChild(note)
		}
	}

	function renderUniqueUrls() {
		if(!rawRows.length) return
		
		const container = document.getElementById('uniqueUrls')
		container.innerHTML = ''
		
		const promptVal = promptFilter.value
		const dayVal = dayFilter.value
		const citationTypeVal = citationTypeFilter.value
		
		// Filter rows based on current filters
		const filteredRows = rawRows.filter(r => {
			if(promptVal !== '__ALL__' && r.Prompt !== promptVal) return false
			if(dayVal !== '__ALL__' && r.Day !== dayVal) return false
			if(citationTypeVal !== '__ALL__' && r.CitationType !== citationTypeVal) return false
			return r.URL && r.URL.trim() !== ''
		})
		
		if(filteredRows.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No data for the selected filters</p>'
			return
		}
		
		// Group by URL
		const urlStats = new Map()
		for(const row of filteredRows) {
			if(!urlStats.has(row.URL)) {
				urlStats.set(row.URL, {
					url: row.URL,
					people: new Set(),
					days: new Set(),
					prompts: new Set(),
					count: 0
				})
			}
			const stats = urlStats.get(row.URL)
			stats.people.add(row.Name)
			stats.days.add(row.Day)
			stats.prompts.add(row.Prompt)
			stats.count++
		}
		
		// Convert to array and calculate consistency metrics
		const urlArray = Array.from(urlStats.values()).map(stats => ({
			url: stats.url,
			peopleCount: stats.people.size,
			daysCount: stats.days.size,
			promptsCount: stats.prompts.size,
			totalCount: stats.count
		}))
		
		// Sort by total count (most frequent first)
		urlArray.sort((a, b) => {
			if(b.totalCount !== a.totalCount) return b.totalCount - a.totalCount
			if(b.daysCount !== a.daysCount) return b.daysCount - a.daysCount
			return b.promptsCount - a.promptsCount
		})
		
		// Show only URLs that appear for exactly 1 person
		const uniqueUrls = urlArray.filter(u => u.peopleCount === 1)
		
		if(uniqueUrls.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No URLs appeared for only one person</p>'
			return
		}
		
	// Create table
	const table = document.createElement('table')
	table.style.width = 'auto'
	table.style.minWidth = '100%'
	table.style.borderCollapse = 'collapse'
	table.style.fontFamily = "'Inter',sans-serif"
	table.style.fontSize = '13px'
	table.style.background = '#fff'
		
		// Header
		const thead = table.createTHead()
		const headerRow = thead.insertRow()
		headerRow.style.background = '#f5f5f5'
		headerRow.style.fontWeight = 'bold'
		
		const headers = ['URL', 'Days', 'Prompts']
		headers.forEach(text => {
			const th = document.createElement('th')
			th.textContent = text
			th.style.padding = '12px'
			th.style.textAlign = 'left'
			th.style.borderBottom = '2px solid #ddd'
			headerRow.appendChild(th)
		})
		
		// Body
		const tbody = table.createTBody()
		uniqueUrls.slice(0, 50).forEach((urlData, idx) => {
			const row = tbody.insertRow()
			row.style.borderBottom = '1px solid #eee'
			if(idx % 2 === 0) row.style.background = '#fafafa'
			
		// URL cell
		const urlCell = row.insertCell()
		urlCell.style.padding = '10px 12px'
		urlCell.style.maxWidth = '400px'
		const link = document.createElement('a')
		link.href = urlData.url
		link.target = '_blank'
		link.textContent = urlData.url
		link.style.color = '#0066cc'
		link.style.textDecoration = 'none'
		link.style.wordBreak = 'break-all'
		link.addEventListener('mouseover', () => link.style.textDecoration = 'underline')
		link.addEventListener('mouseout', () => link.style.textDecoration = 'none')
		urlCell.appendChild(link)
			
			// Stats cells (no people count since it's always 1)
			const daysCell = row.insertCell()
			daysCell.textContent = urlData.daysCount
			daysCell.style.padding = '10px 12px'
			daysCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			daysCell.style.textAlign = 'center'
			
		const promptsCell = row.insertCell()
		promptsCell.textContent = urlData.promptsCount
		promptsCell.style.padding = '10px 12px'
		promptsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
		promptsCell.style.textAlign = 'center'
	})
	
	container.appendChild(table)
	
	if(uniqueUrls.length > 50) {
			const note = document.createElement('p')
			note.style.marginTop = '12px'
			note.style.fontSize = '12px'
			note.style.color = '#666'
			note.style.fontStyle = 'italic'
			note.textContent = `Showing top 50 of ${uniqueUrls.length} unique URLs`
			container.appendChild(note)
		}
	}

	function renderEverPresentDomains() {
		if(!rawRows.length) return
		
		const promptVal = promptFilter.value
		const dayVal = dayFilter.value
		const citationTypeVal = citationTypeFilter.value
		
		// Extract domain from URL
		function getDomain(url) {
			try {
				const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url)
				return urlObj.hostname.replace(/^www\./, '')
			} catch (e) {
				// If URL parsing fails, try to extract domain manually
				const match = url.match(/^(?:https?:\/\/)?(?:www\.)?([^\/]+)/)
				return match ? match[1] : url
			}
		}
		
		// Build stats for each domain
		const domainStats = new Map()
		for(const r of rawRows) {
			if(promptVal !== '__ALL__' && r.Prompt !== promptVal) continue
			if(dayVal !== '__ALL__' && r.Day !== dayVal) continue
			if(citationTypeVal !== '__ALL__' && r.CitationType !== citationTypeVal) continue
			if(!r.URL) continue
			
			const domain = getDomain(r.URL)
			if(!domainStats.has(domain)) {
				domainStats.set(domain, {
					domain: domain,
					people: new Set(),
					days: new Set(),
					prompts: new Set(),
					count: 0
				})
			}
			const stats = domainStats.get(domain)
			stats.people.add(r.Name)
			stats.days.add(r.Day)
			stats.prompts.add(r.Prompt)
			stats.count++
		}
		
		// Filter to only domains that appear for ALL people
		const totalPeople = users.length
		const everPresentDomains = Array.from(domainStats.values())
			.filter(stats => stats.people.size === totalPeople)
			.map(stats => ({
				domain: stats.domain,
				daysCount: stats.days.size,
				promptsCount: stats.prompts.size,
				totalCount: stats.count
			}))
			.sort((a, b) => {
				if(b.daysCount !== a.daysCount) return b.daysCount - a.daysCount
				if(b.promptsCount !== a.promptsCount) return b.promptsCount - a.promptsCount
				return b.totalCount - a.totalCount
			})
		
		const container = document.getElementById('everPresentDomains')
		container.innerHTML = ''
		
		if(everPresentDomains.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No domains appeared for all people</p>'
			return
		}
		
	// Create table
	const table = document.createElement('table')
	table.style.width = 'auto'
	table.style.minWidth = '100%'
	table.style.borderCollapse = 'collapse'
	table.style.fontFamily = "'Inter',sans-serif"
	table.style.fontSize = '13px'
	table.style.background = '#fff'
		
		// Header
		const thead = table.createTHead()
		const headerRow = thead.insertRow()
		headerRow.style.background = '#f5f5f5'
		headerRow.style.fontWeight = 'bold'
		
		const headers = ['Domain', 'People', 'Days', 'Prompts', 'Citations']
		headers.forEach(text => {
			const th = document.createElement('th')
			th.textContent = text
			th.style.padding = '12px'
			th.style.textAlign = 'left'
			th.style.borderBottom = '2px solid #ddd'
			headerRow.appendChild(th)
		})
		
		// Body
		const tbody = table.createTBody()
		everPresentDomains.slice(0, 50).forEach((domainData, idx) => {
			const row = tbody.insertRow()
			row.style.borderBottom = '1px solid #eee'
			if(idx % 2 === 0) row.style.background = '#fafafa'
			
		// Domain cell
		const domainCell = row.insertCell()
		domainCell.textContent = domainData.domain
		domainCell.style.padding = '10px 12px'
		domainCell.style.wordBreak = 'break-all'
		domainCell.style.maxWidth = '300px'
			
			// People cell
			const peopleCell = row.insertCell()
			peopleCell.textContent = totalPeople
			peopleCell.style.padding = '10px 12px'
			peopleCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			peopleCell.style.textAlign = 'center'
			
			// Days cell
			const daysCell = row.insertCell()
			daysCell.textContent = domainData.daysCount
			daysCell.style.padding = '10px 12px'
			daysCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			daysCell.style.textAlign = 'center'
			
			// Prompts cell
			const promptsCell = row.insertCell()
			promptsCell.textContent = domainData.promptsCount
			promptsCell.style.padding = '10px 12px'
			promptsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			promptsCell.style.textAlign = 'center'
			
			// Citations cell
			const citationsCell = row.insertCell()
			citationsCell.textContent = domainData.totalCount
			citationsCell.style.padding = '10px 12px'
			citationsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			citationsCell.style.textAlign = 'center'
		})
		
		container.appendChild(table)
		
		if(everPresentDomains.length > 50) {
			const note = document.createElement('p')
			note.style.marginTop = '12px'
			note.style.fontSize = '12px'
			note.style.color = '#666'
			note.style.fontStyle = 'italic'
			note.textContent = `Showing top 50 of ${everPresentDomains.length} ever-present domains`
			container.appendChild(note)
		}
	}

	function renderUniqueDomains() {
		if(!rawRows.length) return
		
		const promptVal = promptFilter.value
		const dayVal = dayFilter.value
		const citationTypeVal = citationTypeFilter.value
		
		// Extract domain from URL
		function getDomain(url) {
			try {
				const urlObj = new URL(url.startsWith('http') ? url : 'https://' + url)
				return urlObj.hostname.replace(/^www\./, '')
			} catch (e) {
				// If URL parsing fails, try to extract domain manually
				const match = url.match(/^(?:https?:\/\/)?(?:www\.)?([^\/]+)/)
				return match ? match[1] : url
			}
		}
		
		// Build stats for each domain
		const domainStats = new Map()
		for(const r of rawRows) {
			if(promptVal !== '__ALL__' && r.Prompt !== promptVal) continue
			if(dayVal !== '__ALL__' && r.Day !== dayVal) continue
			if(citationTypeVal !== '__ALL__' && r.CitationType !== citationTypeVal) continue
			if(!r.URL) continue
			
			const domain = getDomain(r.URL)
			if(!domainStats.has(domain)) {
				domainStats.set(domain, {
					domain: domain,
					people: new Set(),
					days: new Set(),
					prompts: new Set(),
					count: 0
				})
			}
			const stats = domainStats.get(domain)
			stats.people.add(r.Name)
			stats.days.add(r.Day)
			stats.prompts.add(r.Prompt)
			stats.count++
		}
		
		// Convert to array and filter to only domains with 1 person
		const uniqueDomains = Array.from(domainStats.values())
			.filter(stats => stats.people.size === 1)
			.map(stats => ({
				domain: stats.domain,
				daysCount: stats.days.size,
				promptsCount: stats.prompts.size,
				totalCount: stats.count
			}))
			.sort((a, b) => {
				if(b.daysCount !== a.daysCount) return b.daysCount - a.daysCount
				if(b.promptsCount !== a.promptsCount) return b.promptsCount - a.promptsCount
				return b.totalCount - a.totalCount
			})
		
		const container = document.getElementById('uniqueDomains')
		container.innerHTML = ''
		
		if(uniqueDomains.length === 0) {
			container.innerHTML = '<p style="color:#999;font-style:italic">No unique domains found for the selected filters</p>'
			return
		}
		
	// Create table
	const table = document.createElement('table')
	table.style.width = 'auto'
	table.style.minWidth = '100%'
	table.style.borderCollapse = 'collapse'
	table.style.fontFamily = "'Inter',sans-serif"
	table.style.fontSize = '13px'
	table.style.background = '#fff'
		
		// Header
		const thead = table.createTHead()
		const headerRow = thead.insertRow()
		headerRow.style.background = '#f5f5f5'
		headerRow.style.fontWeight = 'bold'
		
		const headers = ['Domain', 'Days', 'Prompts', 'Citations']
		headers.forEach(text => {
			const th = document.createElement('th')
			th.textContent = text
			th.style.padding = '12px'
			th.style.textAlign = 'left'
			th.style.borderBottom = '2px solid #ddd'
			headerRow.appendChild(th)
		})
		
		// Body
		const tbody = table.createTBody()
		uniqueDomains.slice(0, 50).forEach((domainData, idx) => {
			const row = tbody.insertRow()
			row.style.borderBottom = '1px solid #eee'
			if(idx % 2 === 0) row.style.background = '#fafafa'
			
		// Domain cell
		const domainCell = row.insertCell()
		domainCell.textContent = domainData.domain
		domainCell.style.padding = '10px 12px'
		domainCell.style.wordBreak = 'break-all'
		domainCell.style.maxWidth = '300px'
			
			// Days cell
			const daysCell = row.insertCell()
			daysCell.textContent = domainData.daysCount
			daysCell.style.padding = '10px 12px'
			daysCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			daysCell.style.textAlign = 'center'
			
			// Prompts cell
			const promptsCell = row.insertCell()
			promptsCell.textContent = domainData.promptsCount
			promptsCell.style.padding = '10px 12px'
			promptsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			promptsCell.style.textAlign = 'center'
			
			// Citations cell
			const citationsCell = row.insertCell()
			citationsCell.textContent = domainData.totalCount
			citationsCell.style.padding = '10px 12px'
			citationsCell.style.fontFamily = 'Consolas,"Courier New",monospace'
			citationsCell.style.textAlign = 'center'
		})
		
		container.appendChild(table)
		
		if(uniqueDomains.length > 50) {
			const note = document.createElement('p')
			note.style.marginTop = '12px'
			note.style.fontSize = '12px'
			note.style.color = '#666'
			note.style.fontStyle = 'italic'
			note.textContent = `Showing top 50 of ${uniqueDomains.length} unique domains`
			container.appendChild(note)
		}
	}

	// Auto-load data on page load
	loadDefaultData()

	</script>
</body>
</html>
